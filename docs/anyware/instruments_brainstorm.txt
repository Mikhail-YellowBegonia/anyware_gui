Anyware - Display/Instrument Components (Brainstorm + Filter, Draft)
Updated: 2026-02-13

Goal
- Build a small, high-utility "instrument" set that covers most real dashboards.
- Keep APIs Anyware-first (class components), but don't overfit to GUI engine internals.
- Prefer "few primitives + configuration" when implementations are near-identical.

How We Classify Instruments (from real life)
1) Numeric readouts
- speed, temperature, voltage, FPS, counters
2) Linear meters
- battery, progress, fill level, CPU usage
3) Segmented meters
- signal bars, battery bars, gear/level indicators (N discrete steps)
4) Dial / arc gauges
- speedometer, tachometer, pressure gauge, compass heading, thermometer dial
5) Status indicators
- OK/WARN/FAIL, network connected, recording, alarm, mode state
6) Trend mini-plots
- sparkline / trend line for last N samples (CPU/temp/heart rate)
7) Style-driven instruments (design language)
- multi-segment "digital tube" displays (start with 7-seg digits + decimal point)

Implementation Similarity Grouping (merge vs split)
A) Text-first group (same core)
- ValueText / UnitText / Title+Value blocks
Core: format(value)->string, render via Label/Text

B) Meter group (high similarity, should merge)
- ProgressBar, BatteryBar, SignalBars, LevelIndicator
Core: value -> normalize(0..1) -> fill ratio or N segments -> render rectangles/polys
Recommendation: ONE component "MeterBar" with mode:
- mode="bar" (continuous fill)
- mode="segments" (N discrete segments)

C) Dial group (high similarity, should merge)
- RoundGauge, FanGauge, CompassDial, PressureDial, ThermoDial
Core: value -> normalize(0..1) -> angle span -> needle and/or arc fill
Recommendation: ONE component "DialGauge" with configuration:
- start_angle_deg, end_angle_deg
- style="needle"|"fill"|"both"
- tick config (optional later)

D) Status group (merged into Button)
- StatusLight behavior is modeled as a non-pressable Button with status/lighting.
Core: discrete state -> color/pattern/blink

E) Plot group (different data ownership, keep separate)
- Sparkline / TrendLine
Core: rolling window, downsample, autoscale policy, render polyline

F) Style-driven segment display (logic-heavy, keep separate)
- SegmentDisplay (7-seg / 14-seg / 16-seg)
Core: text -> glyph -> segments on/off -> draw segments
This is "instrument" because it replaces typical numeric readouts with a specific design style.

Draft Component List (full inventory)
P0 (should include early)
- ValueText: single value readout (label + formatted value + optional unit)
- MeterBar: linear meter supporting bar/segments modes
- DialGauge: arc gauge supporting needle/fill/both
- Button (status/lighting): non-pressable status indicator + optional lighting

P0.5 / P1 (design-driven, but valuable)
- SegmentDisplay: 7-seg digits + decimal point (14/16 later)

P1 (later, because needs time window + sampling policy)
- Sparkline (TrendLine): rolling data mini-plot

P2 (later, because mostly composition of P0)
- InstrumentCard: title + instrument + status hint (a ComponentGroup preset)
- MultiInstrumentPanel: layout helpers (still just ComponentGroup + conventions)

Why These Are Enough (coverage argument)
- Most real dashboards are "Value + Meter + Dial + Status" repeated in different layouts.
- SegmentDisplay is a style overlay for numeric instruments (and becomes a reusable design language).
- Trend plots are nice-to-have; they add state ownership (samples) and policy (scale), so delay them.

Proposed Anyware API Shapes (sketch, not final)
ValueText
- value: number|str|callable(ctx)->(number|str)
- format: callable(v)->str (or format string)
- gx, gy (grid positioning), color, orientation

MeterBar
- value/min/max (or value + normalize callable)
- mode="bar"|"segments"
- segments: int (used when mode="segments")
- width_px/height_px, gx/gy anchor, color, empty_color (optional)

DialGauge
- value/min/max (or normalize callable)
- center_gx/center_gy or center_px
- radius_px, start_angle_deg, end_angle_deg
- style="needle"|"fill"|"both"
- color, back_color (optional)

StatusLight (merged into Button)
- use `Button(pressable=False, focusable=False, status=..., status_color_map=...)`

SegmentDisplay (digital tube)
- text: str|callable(ctx)->str  (or value+format)
- style="7seg" (later "14seg"/"16seg")
- digits: int, align="right"|"left", pad_char=" "
- gx/gy anchor (grid) OR x_px/y_px anchor (pixel) (pick one in implementation)
- digit_w_px, digit_h_px, spacing_px, thickness_px
- on_color, off_color (off_color can be dim or None to skip drawing)
- options: show_dp (decimal point), show_colon (clock style)

Notes / Constraints
- Keep defaults conservative; avoid 20 knobs on day one.
- Prefer stable, deterministic rendering: same input -> same pixels.
- SegmentDisplay is allowed to be logic-heavy (glyph/segment mapping), but keep it isolated as one component.

Next Step When Implementing
1) Implement ValueText (trivial, sets conventions).
2) Implement MeterBar with mode="bar" first; add "segments" in same class.
3) Implement DialGauge (reuse the same normalize pipeline as MeterBar).
4) Implement SegmentDisplay (7-seg only, minimal glyph set: 0-9, '-', ' ', '.', ':').
5) Update `apps/app_anyware_demo.py` to include one example per instrument.
